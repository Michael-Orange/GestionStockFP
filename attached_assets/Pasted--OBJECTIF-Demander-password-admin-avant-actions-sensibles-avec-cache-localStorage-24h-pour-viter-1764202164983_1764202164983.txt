# OBJECTIF
Demander password admin avant actions sensibles, avec cache localStorage 24h pour éviter redemander constamment.

# CONTEXTE
POST /api/auth/verify-admin existe et fonctionne ✅
Besoin : Modal password + cache 24h local (pas de modif backend)

# SOLUTION

Frontend uniquement :
- Hook useAdminAuth avec localStorage 24h
- Modal AdminPasswordModal
- Wrapper requireAdminAccess dans admin.tsx
Backend inchangé ✅

# SPÉCIFICATIONS FRONTEND

## 1. Hook useAdminAuth (client/src/hooks/useAdminAuth.ts)

État :
- Lit/écrit localStorage "filtreplante_admin_verified_until"
- Valeur = timestamp expiration (Date.now() + 24h)

Constante :
const ADMIN_SESSION_DURATION = 24 * 60 * 60 * 1000; // 24 heures

Méthodes :

isAdminVerified() : boolean
- Lit localStorage
- Compare Date.now() avec timestamp stocké
- Retourne true si encore valide, false sinon

verifyAdminPassword(userId: number, password: string) : Promise<boolean>
- Appelle POST /api/auth/verify-admin {userId, password}
- Si success (200) :
  * Calcule expiration = Date.now() + ADMIN_SESSION_DURATION
  * localStorage.setItem("filtreplante_admin_verified_until", expiration.toString())
  * Retourne true
- Si échec (401) :
  * Retourne false

requireAdminAccess(action: () => Promise<void>) : Promise<void>
- Si isAdminVerified() :
  * Exécute action() directement
  * Retourne
- Sinon :
  * Affiche modal password (via état React)
  * Attend résultat modal
  * Si password OK : Exécute action()
  * Si annulé : Ne fait rien

clearAdminSession() : void
- localStorage.removeItem("filtreplante_admin_verified_until")
- Optionnel pour bouton "Déconnecter"

Hook retourne :
{
  isAdminVerified,
  requireAdminAccess,
  clearAdminSession,
  showPasswordModal,
  setShowPasswordModal
}

## 2. Modal AdminPasswordModal (client/src/components/admin-password-modal.tsx)

Props :
- isOpen : boolean
- onClose : () => void
- onVerify : (password: string) => Promise<boolean>
- userId : number

État interne :
- password : string
- error : string | null
- isLoading : boolean

Comportement :
- Form avec Input password + Boutons
- onSubmit :
  * setIsLoading(true)
  * result = await onVerify(password)
  * Si true : onClose() (succès)
  * Si false : setError("Mot de passe incorrect")
  * setIsLoading(false)

UI :
- Dialog/Modal centré avec backdrop
- Titre : "Vérification admin requise"
- Input type="password" placeholder="Mot de passe admin"
- Bouton primaire "Valider" (disabled si empty ou loading)
- Bouton secondaire "Annuler"
- {error && <p className="text-destructive">{error}</p>}

Design :
- Responsive mobile (min-h-touch sur input/boutons)
- Couleurs FiltrePlante
- Spinner sur bouton si loading

## 3. Intégration admin.tsx

Import :
import { useAdminAuth } from "@/hooks/useAdminAuth";
import { AdminPasswordModal } from "@/components/admin-password-modal";

Hook :
const { 
  requireAdminAccess, 
  isAdminVerified, 
  showPasswordModal, 
  setShowPasswordModal,
  verifyAdminPassword 
} = useAdminAuth();

const currentUser = useUser(); // Contexte existant

Wrapper actions admin :

Valider produit :
const handleValidateProduct = async (productId: number) => {
  await requireAdminAccess(async () => {
    await validateProductMutation.mutateAsync(productId);
    toast({ title: "Produit validé avec succès" });
  });
};

Modifier produit :
const handleUpdateProduct = async (productId: number, data: any) => {
  await requireAdminAccess(async () => {
    await updateProductMutation.mutateAsync({ id: productId, ...data });
    toast({ title: "Produit modifié" });
  });
};

Supprimer produit :
const handleDeleteProduct = async (productId: number) => {
  if (!confirm("Êtes-vous sûr de vouloir supprimer ce produit ?")) return;
  
  await requireAdminAccess(async () => {
    await deleteProductMutation.mutateAsync(productId);
    toast({ title: "Produit supprimé" });
  });
};

Modal dans JSX :
<AdminPasswordModal
  isOpen={showPasswordModal}
  onClose={() => setShowPasswordModal(false)}
  onVerify={(password) => verifyAdminPassword(currentUser.id, password)}
  userId={currentUser.id}
/>

Badge indicateur (optionnel) :
{isAdminVerified() && (
  <div className="flex items-center gap-2 text-sm text-green-600">
    <CheckCircle className="h-4 w-4" />
    Session admin active (24h)
  </div>
)}

## 4. Import apiRequest existant

Dans useAdminAuth, utiliser apiRequest existant :
import { apiRequest } from "@/lib/queryClient";

const verifyAdminPassword = async (userId: number, password: string) => {
  try {
    const result = await apiRequest("POST", "/api/auth/verify-admin", {
      userId,
      password
    });
    return result.success === true;
  } catch (error) {
    return false;
  }
};

## 5. Persistence localStorage

Au mount du hook :
useEffect(() => {
  const stored = localStorage.getItem("filtreplante_admin_verified_until");
  if (stored) {
    const expiration = parseInt(stored);
    if (Date.now() < expiration) {
      // Session encore valide, rien à faire
    } else {
      // Session expirée, nettoyer
      localStorage.removeItem("filtreplante_admin_verified_until");
    }
  }
}, []);

# BACKEND INCHANGÉ

POST /api/auth/verify-admin reste tel quel ✅
- Vérifie userId + password
- Retourne {success: true/false}

Aucune modification serveur nécessaire ✅

# FLUX UTILISATEUR

Jour 1 - Première action admin :
1. Admin clique "Valider produit"
2. Modal password apparaît
3. Entre password
4. Si OK : Produit validé + cache 24h
5. Modal se ferme

Jour 1 - Actions suivantes :
1. Admin modifie produit → Exécution directe (pas de modal)
2. Admin supprime produit → Exécution directe
3. UX fluide ✅

Jour 2 (< 24h) :
1. Admin ouvre app
2. Clique "Valider produit" → Exécution directe
3. Cache encore valide ✅

Jour 3 (> 24h) :
1. Admin ouvre app
2. Clique "Valider produit"
3. Modal password réapparaît
4. Entre password → Cache 24h renouvelé

# RÉSULTAT ATTENDU

Fichiers créés :

client/src/hooks/useAdminAuth.ts (~100 lignes)
- Hook avec logique localStorage 24h
- Méthodes isAdminVerified, requireAdminAccess, clearAdminSession
- Gestion modal password

client/src/components/admin-password-modal.tsx (~80 lignes)
- Modal UI avec form password
- Gestion loading/erreur
- Design FiltrePlante

Fichiers modifiés :

client/src/pages/admin.tsx (+30 lignes)
- Import hook
- Wrapper actions avec requireAdminAccess
- Modal dans JSX
- Badge optionnel

Backend :
- Aucune modification ✅

Comportement :
- ✅ Password demandé avant actions admin
- ✅ Cache 24h localStorage
- ✅ Persiste entre refreshes
- ✅ Expire automatiquement après 24h
- ✅ UX fluide pour admin

# AVANTAGES VERSION SIMPLIFIÉE

Développement :
- ✅ 1h30 au lieu de 2h30
- ✅ Backend inchangé (zéro risque)
- ✅ Frontend uniquement
- ✅ Moins de complexité

Pragmatisme :
- ✅ Adapté au contexte (5 users confiance)
- ✅ localStorage suffit largement
- ✅ Pas de session backend = moins de maintenance

UX :
- ✅ Password une fois par 24h
- ✅ Actions multiples fluides
- ✅ Simple et efficace

Sécurité suffisante :
- ✅ Actions admin protégées
- ✅ Password vérifié par backend
- ✅ Cache local pas manipulable facilement par users non-techniques

# VALIDATION

Tests :

1. Admin entre password → Actions admin possibles
2. Refresh page dans les 24h → Pas de re-password
3. Ferme app + rouvre dans les 24h → Pas de re-password
4. Attend 24h01 → Re-demande password
5. Annule modal → Action pas exécutée
6. Password incorrect → Message erreur + reste dans modal

Critères succès :
- ✅ Modal password apparaît avant actions admin
- ✅ Cache 24h fonctionne
- ✅ Backend verify-admin appelé correctement
- ✅ UX fluide
- ✅ < 2h de développement

# TEMPS ESTIMÉ

Hook useAdminAuth : 40 min
Modal AdminPasswordModal : 30 min
Intégration admin.tsx : 20 min
Tests : 10 min

Total : 1h30